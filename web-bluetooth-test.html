<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Bluetooth è°ƒè¯•å·¥å…·</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
            animation: fadeInDown 0.5s ease;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.95;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            animation: fadeIn 0.8s ease;
        }

        .card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            backdrop-filter: blur(10px);
        }

        .card h2 {
            color: #333;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            color: #555;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .control-group input[type="text"],
        .control-group input[type="number"],
        .control-group select,
        .control-group textarea {
            width: 100%;
            padding: 10px 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .control-group input:focus,
        .control-group select:focus,
        .control-group textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .control-group textarea {
            resize: vertical;
            min-height: 100px;
            font-family: 'Monaco', 'Courier New', monospace;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 5px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #f5f5f5;
            color: #333;
        }

        .btn-secondary:hover {
            background: #e8e8e8;
        }

        .btn-danger {
            background: #ff4757;
            color: white;
        }

        .btn-danger:hover {
            background: #ff3838;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }

        .status-connected {
            background: #10b981;
        }

        .status-disconnected {
            background: #ef4444;
        }

        .status-scanning {
            background: #f59e0b;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .console {
            background: #1a1a1a;
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            max-height: 300px;
            overflow-y: auto;
        }

        .console-line {
            color: #00ff00;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 12px;
            margin: 5px 0;
            word-wrap: break-word;
        }

        .console-line.error {
            color: #ff4757;
        }

        .console-line.info {
            color: #3498db;
        }

        .console-line.warning {
            color: #f59e0b;
        }

        .device-info {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .device-info p {
            margin: 8px 0;
            color: #555;
        }

        .device-info strong {
            color: #333;
            margin-right: 10px;
        }

        .data-display {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .data-item {
            background: #f0f4f8;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }

        .data-item .label {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }

        .data-item .value {
            font-size: 20px;
            font-weight: bold;
            color: #667eea;
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes fadeInDown {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ”· Web Bluetooth è°ƒè¯•å·¥å…·</h1>
            <p>ä¸“ä¸šçš„è“ç‰™è®¾å¤‡è°ƒè¯•ä¸æµ‹è¯•å¹³å°</p>
        </div>

        <div class="main-content">
            <!-- è¿æ¥æ§åˆ¶é¢æ¿ -->
            <div class="card">
                <h2>ğŸ“¡ è®¾å¤‡è¿æ¥</h2>
                
                <div class="control-group">
                    <div style="padding: 15px; background: linear-gradient(135deg, #f0f8ff, #e6f3ff); border-radius: 10px; border-left: 4px solid #667eea;">
                        <p style="margin: 0 0 5px 0; color: #333; font-weight: 500;">ğŸ’¡ ä½¿ç”¨è¯´æ˜</p>
                        <small style="color: #555; line-height: 1.6;">
                            â€¢ ç‚¹å‡»æ‰«ææŒ‰é’®æ˜¾ç¤ºæ‰€æœ‰é™„è¿‘çš„è“ç‰™è®¾å¤‡<br>
                            â€¢ iOS è®¾å¤‡æ˜¾ç¤ºç³»ç»Ÿè®¾ç½®ä¸­çš„åç§° (å¦‚ "shelchin's iPhone")<br>
                            â€¢ æ­¤åç§°åœ¨ iOS è®¾ç½® > é€šç”¨ > å…³äºæœ¬æœº > åç§° ä¸­é…ç½®<br>
                            â€¢ é€‰æ‹©è®¾å¤‡åè‡ªåŠ¨å‘ç°æ‰€æœ‰å¯ç”¨æœåŠ¡<br>
                         </small>
                    </div>
                </div>
                
                <div class="control-group" style="display: none;">
                    <label>æœåŠ¡ UUIDï¼ˆè‡ªåŠ¨ç®¡ç†ï¼‰</label>
                    <input type="text" id="serviceUuid" placeholder="UUID å°†è‡ªåŠ¨ä¿å­˜å’ŒåŠ è½½" value="">
                    <small style="color: #999;">ç³»ç»Ÿä¼šè‡ªåŠ¨ç®¡ç† UUIDï¼Œæ— éœ€æ‰‹åŠ¨è¾“å…¥</small>
                </div>

                <div class="button-group">
                    <button class="btn btn-primary" id="scanBtn">
                        <span id="scanBtnText">æ‰«æè®¾å¤‡</span>
                    </button>
                    <button class="btn btn-secondary" id="refreshServicesBtn" disabled>
                        åˆ·æ–°æœåŠ¡
                    </button>
                    <button class="btn btn-danger" id="disconnectBtn" disabled>
                        æ–­å¼€è¿æ¥
                    </button>
                    <button class="btn btn-secondary" onclick="
                        if(confirm('æ¸…é™¤æ‰€æœ‰ä¿å­˜çš„ UUIDï¼Ÿ\n\nè¿™å°†åˆ é™¤æ‰€æœ‰å†å²è®°å½•ï¼Œä¸‹æ¬¡éœ€è¦é‡æ–°è¾“å…¥ã€‚')) {
                            localStorage.removeItem('bleServiceUUIDs');
                            localStorage.removeItem('lastServiceUUID');
                            document.getElementById('serviceUuid').value = '';
                            console.log('UUID ç¼“å­˜å·²æ¸…é™¤');
                            alert('UUID ç¼“å­˜å·²æ¸…é™¤ï¼Œè¯·é‡æ–°æ‰«æè®¾å¤‡');
                        }
                    ">
                        ğŸ—‘ï¸ æ¸…é™¤ç¼“å­˜
                    </button>
                </div>

                <div class="device-info" id="deviceInfo" style="display: none;">
                    <p><strong>çŠ¶æ€ï¼š</strong> <span class="status-indicator" id="statusIndicator"></span><span id="connectionStatus">æœªè¿æ¥</span></p>
                    <p><strong>è®¾å¤‡åç§°ï¼š</strong> <span id="deviceName">-</span></p>
                    <p><strong>è®¾å¤‡ ID:</strong> <span id="deviceId">-</span></p>
                    <p><strong>RSSI:</strong> <span id="rssi">-</span> dBm</p>
                </div>

                <h3 style="margin-top: 30px; margin-bottom: 15px; color: #333;">ğŸ“Š æœåŠ¡ä¸ç‰¹å¾</h3>
                <div id="servicesContainer" style="margin-top: 15px;">
                    <p style="color: #999;">è¯·å…ˆè¿æ¥è®¾å¤‡</p>
                </div>
            </div>

            <!-- æ•°æ®äº¤äº’é¢æ¿ -->
            <div class="card">
                <h2>ğŸ“¤ æ•°æ®äº¤äº’</h2>
                
                <div class="control-group">
                    <label>ç‰¹å¾ UUID</label>
                    <select id="characteristicSelect" disabled>
                        <option value="">è¯·å…ˆè¿æ¥è®¾å¤‡</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>å‘é€æ•°æ®ï¼ˆHEX æˆ–æ–‡æœ¬ï¼‰</label>
                    <textarea id="sendData" placeholder="è¾“å…¥è¦å‘é€çš„æ•°æ®..." disabled></textarea>
                </div>

                <div class="control-group">
                    <label>æ•°æ®æ ¼å¼</label>
                    <select id="dataFormat">
                        <option value="text">æ–‡æœ¬ï¼ˆUTF-8ï¼‰</option>
                        <option value="hex">åå…­è¿›åˆ¶</option>
                        <option value="json">JSON</option>
                        <option value="binary">äºŒè¿›åˆ¶</option>
                    </select>
                </div>

                <div class="button-group">
                    <button class="btn btn-primary" id="writeBtn" disabled>å†™å…¥æ•°æ®</button>
                    <button class="btn btn-secondary" id="readBtn" disabled>è¯»å–æ•°æ®</button>
                    <button class="btn btn-secondary" id="subscribeBtn" disabled>è®¢é˜…é€šçŸ¥</button>
                    <button class="btn btn-secondary" id="clearConsoleBtn">æ¸…ç©ºæ§åˆ¶å°</button>
                </div>

                <h3 style="margin-top: 30px; margin-bottom: 15px; color: #333;">ğŸ“ˆ å®æ—¶æ•°æ®</h3>
                <div class="data-display" id="realtimeData">
                    <div class="data-item">
                        <div class="label">æ¥æ”¶å­—èŠ‚</div>
                        <div class="value" id="bytesReceived">0</div>
                    </div>
                    <div class="data-item">
                        <div class="label">å‘é€å­—èŠ‚</div>
                        <div class="value" id="bytesSent">0</div>
                    </div>
                    <div class="data-item">
                        <div class="label">é€šçŸ¥æ•°é‡</div>
                        <div class="value" id="notificationCount">0</div>
                    </div>
                    <div class="data-item">
                        <div class="label">é”™è¯¯æ•°é‡</div>
                        <div class="value" id="errorCount">0</div>
                    </div>
                </div>

                <h3 style="margin-top: 30px; margin-bottom: 15px; color: #333;">ğŸ’» è°ƒè¯•æ§åˆ¶å°</h3>
                <div class="console" id="console"></div>
            </div>
        </div>

        <!-- é«˜çº§åŠŸèƒ½ -->
        <div class="card" style="margin-top: 20px;">
            <h2>ğŸ”§ é«˜çº§åŠŸèƒ½</h2>
            
            <div class="button-group">
                <button class="btn btn-secondary" id="getAllServicesBtn" disabled>è·å–æ‰€æœ‰æœåŠ¡</button>
                <button class="btn btn-secondary" id="getAllCharacteristicsBtn" disabled>è·å–æ‰€æœ‰ç‰¹å¾</button>
                <button class="btn btn-secondary" id="testPerformanceBtn" disabled>æ€§èƒ½æµ‹è¯•</button>
                <button class="btn btn-secondary" id="exportLogsBtn">å¯¼å‡ºæ—¥å¿—</button>
            </div>

            <div class="control-group" style="margin-top: 20px;">
                <label>æ‰¹é‡æµ‹è¯•å‘½ä»¤ï¼ˆæ¯è¡Œä¸€æ¡ï¼‰</label>
                <textarea id="batchCommands" placeholder="WRITE:12345678-1234-5678-1234-56789abcdef1:Hello&#10;READ:12345678-1234-5678-1234-56789abcdef2&#10;WAIT:1000&#10;NOTIFY:12345678-1234-5678-1234-56789abcdef3"></textarea>
                <button class="btn btn-primary" id="runBatchBtn" disabled style="margin-top: 10px;">æ‰§è¡Œæ‰¹é‡æµ‹è¯•</button>
            </div>
        </div>
    </div>

    <script>
        class BluetoothDebugger {
            constructor() {
                this.device = null;
                this.server = null;
                this.services = new Map();
                this.characteristics = new Map();
                this.stats = {
                    bytesReceived: 0,
                    bytesSent: 0,
                    notificationCount: 0,
                    errorCount: 0
                };
                this.logs = [];
                this.autoReconnect = true;
                this.reconnectTimer = null;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 10;
                this.lastHeartbeat = Date.now();
                this.heartbeatCheckTimer = null;
                this.initializeUI();
            }

            initializeUI() {
                // ç»‘å®šäº‹ä»¶å¤„ç†å™¨
                document.getElementById('scanBtn').addEventListener('click', () => this.scanDevice());
                document.getElementById('disconnectBtn').addEventListener('click', () => this.disconnect());
                document.getElementById('refreshServicesBtn').addEventListener('click', () => this.discoverServices());
                document.getElementById('writeBtn').addEventListener('click', () => this.writeData());
                document.getElementById('readBtn').addEventListener('click', () => this.readData());
                document.getElementById('subscribeBtn').addEventListener('click', () => this.subscribeToNotifications());
                document.getElementById('clearConsoleBtn').addEventListener('click', () => this.clearConsole());
                document.getElementById('getAllServicesBtn').addEventListener('click', () => this.getAllServices());
                document.getElementById('getAllCharacteristicsBtn').addEventListener('click', () => this.getAllCharacteristics());
                document.getElementById('testPerformanceBtn').addEventListener('click', () => this.performanceTest());
                document.getElementById('exportLogsBtn').addEventListener('click', () => this.exportLogs());
                document.getElementById('runBatchBtn').addEventListener('click', () => this.runBatchCommands());

                // è‡ªåŠ¨åŠ è½½ä¸Šæ¬¡ä½¿ç”¨çš„ UUID
                const lastUUID = localStorage.getItem('lastServiceUUID');
                if (lastUUID) {
                    document.getElementById('serviceUuid').value = lastUUID;
                    this.log(`å·²åŠ è½½ä¸Šæ¬¡ä½¿ç”¨çš„æœåŠ¡ UUID: ${lastUUID}`, 'info');
                }

                // æ£€æŸ¥æµè§ˆå™¨æ”¯æŒ
                if (!navigator.bluetooth) {
                    this.log('Web Bluetooth API ä¸æ”¯æŒï¼è¯·ä½¿ç”¨ Chrome æµè§ˆå™¨', 'error');
                    this.disableAllButtons();
                } else {
                    this.log('Web Bluetooth è°ƒè¯•å·¥å…·å·²å°±ç»ª', 'info');
                    this.log('âœ… å·²é…ç½®å›ºå®šæœåŠ¡ UUID: 6E400001-B5A3-F393-E0A9-E50E24DCCA9E', 'success');
                    this.log('ğŸ’¡ æ‰€æœ‰è®¾å¤‡ä½¿ç”¨ç›¸åŒçš„ UUIDï¼Œç¡®ä¿è‡ªåŠ¨å‘ç°æœåŠ¡', 'info');
                }
            }

            async scanDevice() {
                try {
                    this.log('å¼€å§‹æ‰«æè“ç‰™è®¾å¤‡...', 'info');
                    
                    const serviceUuid = document.getElementById('serviceUuid').value.trim();
                    
                    // æ‰«æé€‰é¡¹ - æ¥å—æ‰€æœ‰è®¾å¤‡å¹¶åŒ…å«æ‰€æœ‰å¯èƒ½çš„æœåŠ¡
                    let options = {
                        acceptAllDevices: true,
                        optionalServices: [
                            // æˆ‘ä»¬çš„å›ºå®šæœåŠ¡ UUID (Nordic UART Service å…¼å®¹)
                            '6e400001-b5a3-f393-e0a9-e50e24dcca9e',
                            // æ·»åŠ ä¸€äº›é€šç”¨çš„ BLE æœåŠ¡ UUID
                            // 'generic_access',
                            // 'generic_attribute',
                            // 'device_information',
                            // 'battery_service',
                            // æ·»åŠ ä¸€äº›å¸¸è§çš„è‡ªå®šä¹‰æœåŠ¡ UUID èŒƒå›´
                            // '00000000-0000-1000-8000-00805f9b34fb',
                            // '00001800-0000-1000-8000-00805f9b34fb',
                            // '00001801-0000-1000-8000-00805f9b34fb'
                        ]
                    };
                    
                    // å¦‚æœæä¾›äº†æœåŠ¡ UUIDï¼Œæ·»åŠ åˆ° optionalServices
                    if (serviceUuid) {
                        try {
                            // éªŒè¯ UUID æ ¼å¼
                            const uuid = serviceUuid.toLowerCase();
                            // ç¡®ä¿ä¸é‡å¤æ·»åŠ 
                            if (!options.optionalServices.includes(uuid)) {
                                options.optionalServices.push(uuid);
                            }
                            this.log(`å·²æ·»åŠ è‡ªå®šä¹‰æœåŠ¡ UUID: ${uuid}`, 'info');
                        } catch (e) {
                            this.log(`UUID æ ¼å¼é”™è¯¯ï¼š${serviceUuid}`, 'warning');
                        }
                    }
                    
                    // å°è¯•ä»æœ¬åœ°å­˜å‚¨è·å–ä¹‹å‰æˆåŠŸè¿æ¥çš„ UUID
                    const savedUUIDs = localStorage.getItem('bleServiceUUIDs');
                    if (savedUUIDs) {
                        try {
                            const uuids = JSON.parse(savedUUIDs);
                            uuids.forEach(uuid => {
                                const cleanUuid = uuid.toLowerCase().trim();
                                if (!options.optionalServices.includes(cleanUuid)) {
                                    options.optionalServices.push(cleanUuid);
                                    this.log(`æ·»åŠ å†å²æœåŠ¡ UUID: ${cleanUuid}`, 'info');
                                }
                            });
                        } catch (e) {
                            console.error('Failed to parse saved UUIDs:', e);
                        }
                    }
                    
                    // ç¡®ä¿åŠ è½½æœ€åä½¿ç”¨çš„ UUID
                    const lastUUID = localStorage.getItem('lastServiceUUID');
                    if (lastUUID && !options.optionalServices.includes(lastUUID.toLowerCase())) {
                        options.optionalServices.push(lastUUID.toLowerCase());
                        this.log(`æ·»åŠ ä¸Šæ¬¡ä½¿ç”¨çš„ UUID: ${lastUUID}`, 'info');
                    }
                    
                    this.log(`æ‰«æé€‰é¡¹ï¼šæ¥å—æ‰€æœ‰è®¾å¤‡ï¼ŒåŒ…å« ${options.optionalServices.length} ä¸ªå¯é€‰æœåŠ¡`, 'info');

                    this.device = await navigator.bluetooth.requestDevice(options);
                    
                    this.log(`å·²é€‰æ‹©è®¾å¤‡ï¼š${this.device.name || 'Unknown'}`, 'info');
                    
                    // ç›‘å¬æ–­å¼€äº‹ä»¶
                    this.device.addEventListener('gattserverdisconnected', () => {
                        this.log('è®¾å¤‡æ–­å¼€è¿æ¥', 'warning');
                        this.onDisconnected();
                        
                        // è‡ªåŠ¨é‡è¿
                        if (this.autoReconnect && this.reconnectAttempts < this.maxReconnectAttempts) {
                            this.attemptReconnect();
                        }
                    });

                    await this.connectToDevice();
                    
                } catch (error) {
                    this.log(`æ‰«æå¤±è´¥ï¼š${error.message}`, 'error');
                    this.stats.errorCount++;
                    this.updateStats();
                }
            }

            async connectToDevice() {
                try {
                    this.log('æ­£åœ¨è¿æ¥åˆ° GATT æœåŠ¡å™¨...', 'info');
                    this.server = await this.device.gatt.connect();
                    
                    this.log('å·²è¿æ¥åˆ° GATT æœåŠ¡å™¨', 'info');
                    this.log(`è®¾å¤‡ä¿¡æ¯ï¼šID=${this.device.id}, Name=${this.device.name}`, 'info');
                    this.updateConnectionStatus(true);
                    
                    // å»¶è¿Ÿä¸€ä¸‹å†å‘ç°æœåŠ¡
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // è‡ªåŠ¨å‘ç°æœåŠ¡
                    await this.discoverServices();
                    
                } catch (error) {
                    this.log(`è¿æ¥å¤±è´¥ï¼š${error.message}`, 'error');
                    this.stats.errorCount++;
                    this.updateStats();
                }
            }

            async discoverServices() {
                try {
                    this.log('æ­£åœ¨å‘ç°æœåŠ¡...', 'info');
                    
                    // æ£€æŸ¥è¿æ¥çŠ¶æ€
                    if (!this.server || !this.device.gatt.connected) {
                        this.log('è®¾å¤‡æœªè¿æ¥ï¼Œå°è¯•é‡æ–°è¿æ¥...', 'warning');
                        try {
                            this.server = await this.device.gatt.connect();
                            this.log('é‡æ–°è¿æ¥æˆåŠŸ', 'info');
                            await new Promise(resolve => setTimeout(resolve, 500));
                        } catch (e) {
                            this.log('é‡æ–°è¿æ¥å¤±è´¥ï¼š' + e.message, 'error');
                            return;
                        }
                    }
                    
                    let services = [];
                    const serviceUuid = document.getElementById('serviceUuid').value.trim();
                    
                    console.log({serviceUuid,services})
                    // å¦‚æœæä¾›äº†æœåŠ¡ UUIDï¼Œå…ˆå°è¯•è·å–ç‰¹å®šæœåŠ¡
                    if (serviceUuid) {
                        try {
                            this.log(`å°è¯•è·å–æŒ‡å®šæœåŠ¡ï¼š${serviceUuid}`, 'info');
                            const service = await this.server.getPrimaryService(serviceUuid.toLowerCase());
                            services = [service];
                            this.log(`âœ… æˆåŠŸè·å–æœåŠ¡ï¼š${service.uuid}`, 'success');
                        } catch (e) {
                            this.log(`æ— æ³•è·å–æŒ‡å®šæœåŠ¡ï¼š${e.message}`, 'warning');
                            // ç»§ç»­å°è¯•è·å–æ‰€æœ‰æœåŠ¡
                        }
                    }
                    
                    // å¦‚æœæ²¡æœ‰è·å–åˆ°æœåŠ¡ï¼Œå°è¯•è·å–æ‰€æœ‰æœåŠ¡
                    if (services.length === 0) {
                        try {
                            this.log('å°è¯•è·å–æ‰€æœ‰å¯ç”¨æœåŠ¡...', 'info');
                            services = await this.server.getPrimaryServices();
                            this.log(`å‘ç° ${services.length} ä¸ªæœåŠ¡`, 'info');
                            console.log("000",services)
                            
                            if (services.length === 0) {
                                this.log('âš ï¸ æ²¡æœ‰å‘ç°ä»»ä½•æœåŠ¡ï¼', 'warning');
                                this.log('Web Bluetooth é™åˆ¶ï¼šå¿…é¡»åœ¨æ‰«ææ—¶å£°æ˜è¦è®¿é—®çš„æœåŠ¡', 'warning');
                                
                                // è‡ªåŠ¨æç¤ºç”¨æˆ·è¾“å…¥ UUID
                                const userUUID = prompt('è¯·è¾“å…¥ iOS åº”ç”¨"è®¾ç½®"é¡µæ˜¾ç¤ºçš„æœåŠ¡ UUIDï¼š\n\nä¾‹å¦‚ï¼š12345678-1234-1234-1234-123456789012\n\næç¤ºï¼šæ‰“å¼€ iOS åº”ç”¨ â†’ è®¾ç½®æ ‡ç­¾ â†’ æŸ¥çœ‹"æœåŠ¡ UUID"');
                                if (userUUID && userUUID.trim()) {
                                    const cleanUUID = userUUID.trim().toLowerCase();
                                    this.log(`ä¿å­˜ UUID: ${cleanUUID}`, 'info');
                                    
                                    // ä¿å­˜ UUID
                                    document.getElementById('serviceUuid').value = cleanUUID;
                                    localStorage.setItem('lastServiceUUID', cleanUUID);
                                    
                                    // æ·»åŠ åˆ°å·²çŸ¥æœåŠ¡åˆ—è¡¨
                                    let savedUUIDs = [];
                                    try {
                                        const existing = localStorage.getItem('bleServiceUUIDs');
                                        if (existing) {
                                            savedUUIDs = JSON.parse(existing);
                                        }
                                    } catch (e) {}
                                    
                                    if (!savedUUIDs.includes(cleanUUID)) {
                                        savedUUIDs.push(cleanUUID);
                                        localStorage.setItem('bleServiceUUIDs', JSON.stringify(savedUUIDs));
                                    }
                                    
                                    this.log('âœ… UUID å·²ä¿å­˜ï¼Œæ­£åœ¨è‡ªåŠ¨é‡æ–°è¿æ¥...', 'success');
                                    
                                    // è‡ªåŠ¨æ–­å¼€å¹¶é‡æ–°è¿æ¥
                                    setTimeout(async () => {
                                        await this.disconnect();
                                        setTimeout(() => {
                                            this.scanDevice();
                                        }, 500);
                                    }, 100);
                                }
                            } else {
                                this.log('æœåŠ¡åˆ—è¡¨ï¼š', 'info');
                                for (const s of services) {
                                    this.log(`  ğŸ“¦ æœåŠ¡ UUID: ${s.uuid}`, 'info');
                                }
                            }
                        } catch (e) {
                            this.log(`è·å–æœåŠ¡å¤±è´¥ï¼š${e.message}`, 'error');
                            this.log('ğŸ’¡ è¯·ä» iOS åº”ç”¨å¤åˆ¶æœåŠ¡ UUID å¹¶é‡æ–°æ‰«æ', 'warning');
                            services = [];
                        }
                    }
                    
                    this.services.clear();
                    this.characteristics.clear();
                    
                    const servicesContainer = document.getElementById('servicesContainer');
                    servicesContainer.innerHTML = '';
                    
                    const characteristicSelect = document.getElementById('characteristicSelect');
                    characteristicSelect.innerHTML = '<option value="">é€‰æ‹©ç‰¹å¾</option>';
                    
                    for (const service of services) {
                    console.log({services})
                        this.services.set(service.uuid, service);
                        this.log(`å‘ç°æœåŠ¡ï¼š${service.uuid}`, 'info');
                        
                        const serviceDiv = document.createElement('div');
                        serviceDiv.style.marginBottom = '15px';
                        serviceDiv.innerHTML = `<strong>æœåŠ¡:</strong> ${service.uuid}`;
                        servicesContainer.appendChild(serviceDiv);
                        
                        try {
                            // å°è¯•è·å–æ‰€æœ‰ç‰¹å¾
                            this.log(`æ­£åœ¨è·å–æœåŠ¡ ${service.uuid} çš„ç‰¹å¾...`, 'info');
                            const characteristics = await service.getCharacteristics();
                            this.log(`æœåŠ¡ ${service.uuid} æœ‰ ${characteristics.length} ä¸ªç‰¹å¾`, 'info');
                            
                            if (characteristics.length === 0) {
                                this.log(`è­¦å‘Šï¼šæœåŠ¡æ²¡æœ‰ä»»ä½•ç‰¹å¾`, 'warning');
                            }
                            
                            for (const char of characteristics) {
                                this.characteristics.set(char.uuid, char);
                                
                                const properties = [];
                                if (char.properties.read) properties.push('READ');
                                if (char.properties.write) properties.push('WRITE');
                                if (char.properties.notify) properties.push('NOTIFY');
                                if (char.properties.indicate) properties.push('INDICATE');
                                if (char.properties.writeWithoutResponse) properties.push('WRITE_NO_RSP');
                                
                                const charDiv = document.createElement('div');
                                charDiv.style.marginLeft = '20px';
                                charDiv.style.fontSize = '14px';
                                charDiv.style.color = '#666';
                                charDiv.innerHTML = `ç‰¹å¾ï¼š${char.uuid} [${properties.join(', ')}]`;
                                serviceDiv.appendChild(charDiv);
                                
                                const option = document.createElement('option');
                                option.value = char.uuid;
                                option.text = `${char.uuid} [${properties.join(', ')}]`;
                                characteristicSelect.appendChild(option);
                            }
                        } catch (error) {
                            this.log(`è·å–ç‰¹å¾å¤±è´¥ï¼š${error.message}`, 'warning');
                        }
                    }
                    
                    this.log(`å‘ç° ${services.length} ä¸ªæœåŠ¡ï¼Œ${this.characteristics.size} ä¸ªç‰¹å¾`, 'info');
                    
                    // ä¿å­˜æˆåŠŸå‘ç°çš„æœåŠ¡ UUID åˆ°æœ¬åœ°å­˜å‚¨
                    if (services.length > 0) {
                        const serviceUUIDs = services.map(s => s.uuid);
                        try {
                            localStorage.setItem('bleServiceUUIDs', JSON.stringify(serviceUUIDs));
                            this.log('å·²ä¿å­˜æœåŠ¡ UUID ä¾›ä¸‹æ¬¡ä½¿ç”¨', 'info');
                        } catch (e) {
                            console.error('Failed to save UUIDs:', e);
                        }
                    }
                    
                    this.enableDataControls();
                    
                } catch (error) {
                    this.log(`æœåŠ¡å‘ç°å¤±è´¥ï¼š${error.message}`, 'error');
                    this.stats.errorCount++;
                    this.updateStats();
                }
            }

            async writeData() {
                try {
                    const charUuid = document.getElementById('characteristicSelect').value;
                    const data = document.getElementById('sendData').value;
                    const format = document.getElementById('dataFormat').value;
                    
                    if (!charUuid) {
                        this.log('è¯·é€‰æ‹©ç‰¹å¾', 'warning');
                        return;
                    }
                    
                    const characteristic = this.characteristics.get(charUuid);
                    if (!characteristic) {
                        this.log('ç‰¹å¾æœªæ‰¾åˆ°', 'error');
                        return;
                    }
                    
                    let buffer;
                    
                    switch (format) {
                        case 'hex':
                            const hex = data.replace(/\s/g, '');
                            const bytes = hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16));
                            buffer = new Uint8Array(bytes).buffer;
                            break;
                        case 'json':
                            const jsonStr = JSON.stringify(JSON.parse(data));
                            buffer = new TextEncoder().encode(jsonStr).buffer;
                            break;
                        case 'binary':
                            const binaryBytes = data.split(',').map(b => parseInt(b.trim()));
                            buffer = new Uint8Array(binaryBytes).buffer;
                            break;
                        default: // text
                            buffer = new TextEncoder().encode(data).buffer;
                    }
                    
                    await characteristic.writeValue(buffer);
                    
                    this.stats.bytesSent += buffer.byteLength;
                    this.updateStats();
                    
                    this.log(`å·²å†™å…¥ ${buffer.byteLength} å­—èŠ‚åˆ° ${charUuid}`, 'info');
                    
                } catch (error) {
                    this.log(`å†™å…¥å¤±è´¥ï¼š${error.message}`, 'error');
                    this.stats.errorCount++;
                    this.updateStats();
                }
            }

            async readData() {
                try {
                    const charUuid = document.getElementById('characteristicSelect').value;
                    
                    if (!charUuid) {
                        this.log('è¯·é€‰æ‹©ç‰¹å¾', 'warning');
                        return;
                    }
                    
                    const characteristic = this.characteristics.get(charUuid);
                    if (!characteristic) {
                        this.log('ç‰¹å¾æœªæ‰¾åˆ°', 'error');
                        return;
                    }
                    
                    const value = await characteristic.readValue();
                    const decoder = new TextDecoder();
                    const text = decoder.decode(value);
                    const hex = Array.from(new Uint8Array(value.buffer))
                        .map(b => b.toString(16).padStart(2, '0'))
                        .join(' ');
                    
                    this.stats.bytesReceived += value.byteLength;
                    this.updateStats();
                    
                    this.log(`è¯»å–åˆ°æ•°æ® (${value.byteLength} å­—èŠ‚):`, 'info');
                    this.log(`  æ–‡æœ¬ï¼š${text}`, 'info');
                    this.log(`  HEX: ${hex}`, 'info');
                    
                } catch (error) {
                    this.log(`è¯»å–å¤±è´¥ï¼š${error.message}`, 'error');
                    this.stats.errorCount++;
                    this.updateStats();
                }
            }

            async subscribeToNotifications() {
                try {
                    const charUuid = document.getElementById('characteristicSelect').value;
                    
                    if (!charUuid) {
                        this.log('è¯·é€‰æ‹©ç‰¹å¾', 'warning');
                        return;
                    }
                    
                    const characteristic = this.characteristics.get(charUuid);
                    if (!characteristic) {
                        this.log('ç‰¹å¾æœªæ‰¾åˆ°', 'error');
                        return;
                    }
                    
                    if (!characteristic.properties.notify && !characteristic.properties.indicate) {
                        this.log('è¯¥ç‰¹å¾ä¸æ”¯æŒé€šçŸ¥æˆ–æŒ‡ç¤º', 'warning');
                        return;
                    }
                    
                    await characteristic.startNotifications();
                    
                    characteristic.addEventListener('characteristicvaluechanged', (event) => {
                        const value = event.target.value;
                        const decoder = new TextDecoder();
                        const text = decoder.decode(value);
                        const hex = Array.from(new Uint8Array(value.buffer))
                            .map(b => b.toString(16).padStart(2, '0'))
                            .join(' ');
                        
                        this.stats.bytesReceived += value.byteLength;
                        this.stats.notificationCount++;
                        this.updateStats();
                        
                        this.log(`æ”¶åˆ°é€šçŸ¥ (${value.byteLength} å­—èŠ‚):`, 'info');
                        this.log(`  æ–‡æœ¬ï¼š${text}`, 'info');
                        this.log(`  HEX: ${hex}`, 'info');
                    });
                    
                    this.log(`å·²è®¢é˜… ${charUuid} çš„é€šçŸ¥`, 'info');
                    
                } catch (error) {
                    this.log(`è®¢é˜…å¤±è´¥ï¼š${error.message}`, 'error');
                    this.stats.errorCount++;
                    this.updateStats();
                }
            }

            async getAllServices() {
                try {
                    this.log('è·å–æ‰€æœ‰å¯ç”¨æœåŠ¡...', 'info');
                    const services = await this.server.getPrimaryServices();
                    
                    for (const service of services) {
                        this.log(`æœåŠ¡ï¼š${service.uuid}`, 'info');
                        
                        try {
                            const chars = await service.getCharacteristics();
                            for (const char of chars) {
                                const properties = [];
                                if (char.properties.read) properties.push('R');
                                if (char.properties.write) properties.push('W');
                                if (char.properties.notify) properties.push('N');
                                this.log(`  â””â”€ ç‰¹å¾ï¼š${char.uuid} [${properties.join('')}]`, 'info');
                            }
                        } catch (e) {
                            this.log(`  â””â”€ æ— æ³•è·å–ç‰¹å¾`, 'warning');
                        }
                    }
                } catch (error) {
                    this.log(`è·å–æœåŠ¡å¤±è´¥ï¼š${error.message}`, 'error');
                }
            }

            async getAllCharacteristics() {
                try {
                    this.log('è·å–æ‰€æœ‰ç‰¹å¾è¯¦æƒ…...', 'info');
                    
                    for (const [uuid, char] of this.characteristics) {
                        const properties = [];
                        if (char.properties.read) properties.push('READ');
                        if (char.properties.write) properties.push('WRITE');
                        if (char.properties.writeWithoutResponse) properties.push('WRITE_NO_RSP');
                        if (char.properties.notify) properties.push('NOTIFY');
                        if (char.properties.indicate) properties.push('INDICATE');
                        
                        this.log(`ç‰¹å¾ ${uuid}:`, 'info');
                        this.log(`  å±æ€§ï¼š${properties.join(', ')}`, 'info');
                        
                        if (char.properties.read) {
                            try {
                                const value = await char.readValue();
                                const hex = Array.from(new Uint8Array(value.buffer))
                                    .map(b => b.toString(16).padStart(2, '0'))
                                    .join(' ');
                                this.log(`  å½“å‰å€¼ï¼š${hex}`, 'info');
                            } catch (e) {
                                this.log(`  æ— æ³•è¯»å–å€¼`, 'warning');
                            }
                        }
                    }
                } catch (error) {
                    this.log(`è·å–ç‰¹å¾å¤±è´¥ï¼š${error.message}`, 'error');
                }
            }

            async performanceTest() {
                try {
                    this.log('å¼€å§‹æ€§èƒ½æµ‹è¯•...', 'info');
                    
                    // æµ‹è¯•ä¸åŒçš„æ•°æ®åŒ…å¤§å°
                    const packetSizes = [20, 100, 185, 244,500]; // å¸¸è§çš„ BLE MTU å€¼
                    const iterations = 100;
                    let writeChar = null;
                    let useWriteWithoutResponse = false;
                    
                    // æ‰¾åˆ°æ”¯æŒ writeWithoutResponse çš„ç‰¹å¾ï¼ˆæ€§èƒ½æ›´å¥½ï¼‰
                    for (const [uuid, char] of this.characteristics) {
                        if (char.properties.writeWithoutResponse) {
                            writeChar = char;
                            useWriteWithoutResponse = true;
                            this.log(`ä½¿ç”¨ç‰¹å¾ ${uuid} (WriteWithoutResponse)`, 'info');
                            break;
                        } else if (char.properties.write) {
                            writeChar = char;
                            this.log(`ä½¿ç”¨ç‰¹å¾ ${uuid} (Write)`, 'info');
                        }
                    }
                    
                    if (!writeChar) {
                        this.log('æ²¡æœ‰æ‰¾åˆ°å¯å†™ç‰¹å¾', 'warning');
                        return;
                    }
                    
                    // æµ‹è¯•ä¸åŒåŒ…å¤§å°
                    for (const size of packetSizes) {
                        this.log(`\næµ‹è¯•åŒ…å¤§å°ï¼š${size} å­—èŠ‚`, 'info');
                        const testData = new Uint8Array(size).fill(0x42);
                        
                        try {
                            const startTime = performance.now();
                            let successCount = 0;
                            
                            for (let i = 0; i < iterations; i++) {
                                try {
                                    if (useWriteWithoutResponse) {
                                        await writeChar.writeValueWithoutResponse(testData);
                                    } else {
                                        await writeChar.writeValueWithResponse(testData);
                                    }
                                    successCount++;
                                    if (i % 20 === 0) {
                                        this.log(`  è¿›åº¦: ${i}/${iterations}`, 'info');
                                    }
                                } catch (e) {
                                    // å¦‚æœåŒ…å¤ªå¤§ï¼Œè·³è¿‡
                                    if (e.message.includes('too large') || e.message.includes('MTU')) {
                                        this.log(`  åŒ…å¤§å° ${size} è¶…è¿‡ MTU é™åˆ¶`, 'warning');
                                        break;
                                    }
                                    throw e;
                                }
                            }
                            
                            if (successCount > 0) {
                                const endTime = performance.now();
                                const totalTime = endTime - startTime;
                                const avgTime = totalTime / successCount;
                                const throughput = (testData.byteLength * successCount * 1000) / totalTime;
                                
                                this.log(`  æˆåŠŸå‘é€ï¼š${successCount} ä¸ªåŒ…`, 'info');
                                this.log(`  æ€»æ—¶é—´ï¼š${totalTime.toFixed(2)} ms`, 'info');
                                this.log(`  å¹³å‡å»¶è¿Ÿï¼š${avgTime.toFixed(2)} ms`, 'info');
                                this.log(`  ååé‡ï¼š${throughput.toFixed(2)} bytes/s`, 'success');
                            }
                        } catch (error) {
                            this.log(`  æµ‹è¯•å¤±è´¥ï¼š${error.message}`, 'error');
                        }
                    }
                    
                    this.log('\næ€§èƒ½æµ‹è¯•å®Œæˆï¼', 'success');
                    this.log('æç¤ºï¼šä½¿ç”¨ WriteWithoutResponse å’Œè¾ƒå¤§çš„åŒ…å¯ä»¥è·å¾—æ›´å¥½çš„æ€§èƒ½', 'info');
                    
                } catch (error) {
                    this.log(`æ€§èƒ½æµ‹è¯•å¤±è´¥ï¼š${error.message}`, 'error');
                }
            }

            async runBatchCommands() {
                try {
                    const commands = document.getElementById('batchCommands').value.split('\n');
                    
                    this.log('å¼€å§‹æ‰§è¡Œæ‰¹é‡å‘½ä»¤...', 'info');
                    
                    for (const command of commands) {
                        if (!command.trim()) continue;
                        
                        const parts = command.split(':');
                        const action = parts[0].toUpperCase();
                        
                        switch (action) {
                            case 'WRITE':
                                const writeUuid = parts[1];
                                const writeData = parts[2];
                                const writeChar = this.characteristics.get(writeUuid);
                                if (writeChar) {
                                    await writeChar.writeValue(new TextEncoder().encode(writeData));
                                    this.log(`WRITE ${writeUuid}: ${writeData}`, 'info');
                                }
                                break;
                                
                            case 'READ':
                                const readUuid = parts[1];
                                const readChar = this.characteristics.get(readUuid);
                                if (readChar) {
                                    const value = await readChar.readValue();
                                    const text = new TextDecoder().decode(value);
                                    this.log(`READ ${readUuid}: ${text}`, 'info');
                                }
                                break;
                                
                            case 'WAIT':
                                const ms = parseInt(parts[1]);
                                await new Promise(resolve => setTimeout(resolve, ms));
                                this.log(`WAIT ${ms}ms`, 'info');
                                break;
                                
                            case 'NOTIFY':
                                const notifyUuid = parts[1];
                                const notifyChar = this.characteristics.get(notifyUuid);
                                if (notifyChar && notifyChar.properties.notify) {
                                    await notifyChar.startNotifications();
                                    this.log(`NOTIFY ${notifyUuid}: å·²å¯åŠ¨`, 'info');
                                }
                                break;
                        }
                    }
                    
                    this.log('æ‰¹é‡å‘½ä»¤æ‰§è¡Œå®Œæˆ', 'info');
                    
                } catch (error) {
                    this.log(`æ‰¹é‡æ‰§è¡Œå¤±è´¥ï¼š${error.message}`, 'error');
                }
            }

            disconnect() {
                // åœæ­¢è‡ªåŠ¨é‡è¿
                this.autoReconnect = false;
                this.reconnectAttempts = 0;
                
                if (this.device && this.device.gatt.connected) {
                    this.device.gatt.disconnect();
                    this.log('å·²ä¸»åŠ¨æ–­å¼€è¿æ¥', 'info');
                }
                this.onDisconnected();
            }

            onDisconnected() {
                // ä¸æ¸…é™¤ device å¯¹è±¡ï¼Œä»¥ä¾¿èƒ½å¤Ÿé‡è¿
                // this.device = null;  // æ³¨é‡Šæ‰è¿™è¡Œ
                this.server = null;
                this.services.clear();
                this.characteristics.clear();
                this.updateConnectionStatus(false);
                this.disableDataControls();
                
                document.getElementById('servicesContainer').innerHTML = '<p style="color: #999;">è¯·å…ˆè¿æ¥è®¾å¤‡</p>';
                document.getElementById('characteristicSelect').innerHTML = '<option value="">è¯·å…ˆè¿æ¥è®¾å¤‡</option>';
            }
            
            async attemptReconnect() {
                this.reconnectAttempts++;
                this.log(`å°è¯•é‡æ–°è¿æ¥... (ç¬¬ ${this.reconnectAttempts} æ¬¡)`, 'info');
                
                // è®¾ç½®å»¶è¿Ÿé‡è¿ï¼Œä½¿ç”¨æŒ‡æ•°é€€é¿ç®—æ³•
                const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts - 1), 30000);
                
                setTimeout(async () => {
                    try {
                        if (this.device && !this.device.gatt.connected) {
                            await this.connectToDevice();
                            this.reconnectAttempts = 0;
                            this.log('âœ… é‡æ–°è¿æ¥æˆåŠŸï¼', 'success');
                            this.startHeartbeatMonitor();
                        }
                    } catch (error) {
                        this.log(`é‡è¿å¤±è´¥ï¼š${error.message}`, 'error');
                        
                        if (this.autoReconnect && this.reconnectAttempts < this.maxReconnectAttempts) {
                            this.attemptReconnect();
                        } else {
                            this.log('å·²è¾¾åˆ°æœ€å¤§é‡è¿æ¬¡æ•°ï¼Œåœæ­¢é‡è¿', 'error');
                            this.autoReconnect = false;
                        }
                    }
                }, delay);
                
                this.log(`å°†åœ¨ ${delay/1000} ç§’åé‡è¿`, 'info');
            }
            
            startHeartbeatMonitor() {
                // ç›‘å¬å¿ƒè·³æ¶ˆæ¯
                this.log('ğŸ’“ å¼€å§‹ç›‘æµ‹å¿ƒè·³', 'info');
                this.lastHeartbeat = Date.now();
            }

            updateConnectionStatus(connected) {
                const statusIndicator = document.getElementById('statusIndicator');
                const connectionStatus = document.getElementById('connectionStatus');
                const deviceInfo = document.getElementById('deviceInfo');
                const deviceName = document.getElementById('deviceName');
                const deviceId = document.getElementById('deviceId');
                
                if (connected) {
                    statusIndicator.className = 'status-indicator status-connected';
                    connectionStatus.textContent = 'å·²è¿æ¥';
                    deviceInfo.style.display = 'block';
                    deviceName.textContent = this.device.name || 'Unknown';
                    deviceId.textContent = this.device.id || '-';
                    
                    document.getElementById('scanBtn').disabled = true;
                    document.getElementById('disconnectBtn').disabled = false;
                    document.getElementById('refreshServicesBtn').disabled = false;
                    document.getElementById('getAllServicesBtn').disabled = false;
                    document.getElementById('getAllCharacteristicsBtn').disabled = false;
                    document.getElementById('testPerformanceBtn').disabled = false;
                    document.getElementById('runBatchBtn').disabled = false;
                } else {
                    statusIndicator.className = 'status-indicator status-disconnected';
                    connectionStatus.textContent = 'æœªè¿æ¥';
                    deviceInfo.style.display = 'none';
                    
                    document.getElementById('scanBtn').disabled = false;
                    document.getElementById('disconnectBtn').disabled = true;
                    document.getElementById('refreshServicesBtn').disabled = true;
                    document.getElementById('getAllServicesBtn').disabled = true;
                    document.getElementById('getAllCharacteristicsBtn').disabled = true;
                    document.getElementById('testPerformanceBtn').disabled = true;
                    document.getElementById('runBatchBtn').disabled = true;
                }
            }

            enableDataControls() {
                document.getElementById('characteristicSelect').disabled = false;
                document.getElementById('sendData').disabled = false;
                document.getElementById('writeBtn').disabled = false;
                document.getElementById('readBtn').disabled = false;
                document.getElementById('subscribeBtn').disabled = false;
            }

            disableDataControls() {
                document.getElementById('characteristicSelect').disabled = true;
                document.getElementById('sendData').disabled = true;
                document.getElementById('writeBtn').disabled = true;
                document.getElementById('readBtn').disabled = true;
                document.getElementById('subscribeBtn').disabled = true;
            }

            disableAllButtons() {
                const buttons = document.querySelectorAll('button');
                buttons.forEach(btn => btn.disabled = true);
            }

            log(message, type = 'normal') {
                const console = document.getElementById('console');
                const line = document.createElement('div');
                line.className = `console-line ${type}`;
                
                const timestamp = new Date().toLocaleTimeString();
                line.textContent = `[${timestamp}] ${message}`;
                
                console.appendChild(line);
                console.scrollTop = console.scrollHeight;
                
                // ä¿å­˜æ—¥å¿—
                this.logs.push({
                    timestamp: new Date().toISOString(),
                    message,
                    type
                });
            }

            clearConsole() {
                document.getElementById('console').innerHTML = '';
                this.log('æ§åˆ¶å°å·²æ¸…ç©º', 'info');
            }

            updateStats() {
                document.getElementById('bytesReceived').textContent = this.stats.bytesReceived;
                document.getElementById('bytesSent').textContent = this.stats.bytesSent;
                document.getElementById('notificationCount').textContent = this.stats.notificationCount;
                document.getElementById('errorCount').textContent = this.stats.errorCount;
            }

            exportLogs() {
                const logData = {
                    exportTime: new Date().toISOString(),
                    stats: this.stats,
                    logs: this.logs
                };
                
                const blob = new Blob([JSON.stringify(logData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `bluetooth-debug-logs-${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                this.log('æ—¥å¿—å·²å¯¼å‡º', 'info');
            }
        }

        // åˆå§‹åŒ–è°ƒè¯•å™¨
        const btDebugger = new BluetoothDebugger();
    </script>
</body>
</html>